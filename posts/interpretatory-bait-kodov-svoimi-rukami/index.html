<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# " lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Интерпретаторы байт-кодов своими руками | Языки и компиляторы</title>
<link href="../../assets/css/bootstrap.min.css" rel="stylesheet" type="text/css">
<link href="../../assets/css/baguetteBox.min.css" rel="stylesheet" type="text/css">
<link href="../../assets/css/rst.css" rel="stylesheet" type="text/css">
<link href="../../assets/css/code.css" rel="stylesheet" type="text/css">
<link href="../../assets/css/theme.css" rel="stylesheet" type="text/css">
<link href="../../assets/css/bootblog.css" rel="stylesheet" type="text/css">
<link href="../../assets/css/custom.css" rel="stylesheet" type="text/css">
<link href="https://fonts.googleapis.com/css?family=Playfair+Display:700,900" rel="stylesheet">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" href="../../rss.xml">
<link rel="canonical" href="https://plcomp.github.io/posts/interpretatory-bait-kodov-svoimi-rukami/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Языки и компиляторы">
<meta property="og:site_name" content="Языки и компиляторы">
<meta property="og:title" content="Интерпретаторы байт-кодов своими руками">
<meta property="og:url" content="https://plcomp.github.io/posts/interpretatory-bait-kodov-svoimi-rukami/">
<meta property="og:description" content="Виртуальные машины языков программирования в последние десятилетия получили весьма широкое распространение. С презентации Java Virtual Machine во второй половине 90-х прошло уже достаточно много време">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2019-01-15T11:55:05+03:00">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Перейти к главному содержимому</a>

<!-- Header and menu bar -->
<div class="container pb-2">
    <header class="blog-header"><div class="row nbb-header align-items-center pt-3 pb-1">
            <div class="col-md-2 col-xs-2 col-sm-2" style="width: auto;">
                <button class="navbar-toggler navbar-light bg-light nbb-navbar-toggler" type="button" data-toggle="collapse" data-target=".bs-nav-collapsible" aria-controls="bs-navbar" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>
                <div class="collapse bs-nav-collapsible bootblog4-search-form-holder">
                    
                </div>
            </div>
            <div class="col-md-8 col-xs-10 col-sm-10 bootblog4-brand" style="width: auto;">
                <a class="navbar-brand blog-header-logo text-dark" href="https://plcomp.github.io/">

                        <span id="blog-title">Языки и компиляторы</span>
                </a>
            </div>
            <div class="col-md-2 justify-content-end align-items-center bs-nav-collapsible collapse flex-collapse bootblog4-right-nav">
                <nav class="navbar navbar-light bg-white"><ul class="navbar-nav bootblog4-right-nav"></ul></nav>
</div>
        </div>
        <div class="row align-items-center pt-2 pb-3">
            <div class="col bootblog4-brand" style="width: auto">
                    <span class="blog-description">Теория и практика разработки языков программирования и инструментальных средств</span>
            </div>
        </div>
    </header><nav class="navbar navbar-expand-md navbar-light bg-white static-top"><div class="collapse navbar-collapse bs-nav-collapsible" id="bs-navbar">
            <ul class="navbar-nav nav-fill d-flex w-100">
<li class="nav-item">
<a href="../../pages/about/" class="nav-link">О журнале</a>
                </li>
<li class="nav-item">
<a href="../../pages/authors/" class="nav-link">Авторам</a>
                </li>
<li class="nav-item">
<a href="../../archive.html" class="nav-link">Архив</a>
                </li>
<li class="nav-item">
<a href="../../categories/" class="nav-link">Тэги</a>
                </li>
<li class="nav-item">
<a href="../../rss.xml" class="nav-link">RSS</a>

                
            </li>
</ul>
</div>
<!-- /.navbar-collapse -->
    </nav>
</div>

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        
        
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name">Интерпретаторы байт-кодов своими руками</h1>

        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                    Языки и компиляторы
            </span></p>
            <p class="dateline">
            <time class="published dt-published" datetime="2019-01-15T11:55:05+03:00" itemprop="datePublished" title="2019-01-15 11:55">2019-01-15 11:55</time></p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <div>
<p>Виртуальные машины языков программирования в последние десятилетия получили весьма широкое распространение. С презентации Java Virtual Machine во второй половине 90-х прошло уже достаточно много времени, и можно с уверенностью сказать, что интерпретаторы байт-кодов - не будущее, а настоящее.</p>
<p>Но данная техника, на мой взгляд, практически универсальна, и понимание основных принципов разработки интерпретаторов пригодится не только создателю очередного претендента на звание "Язык года" по версии <a href="https://www.tiobe.com/tiobe-index/">TIOBE</a>, но вообще любому программисту.</p>
<p>Словом, если вам интересно узнать, как складывают числа наши любимые языки программирования, о чём до сих пор спорят разработчики виртуальных машин и как безболезненно сопоставлять строки и регулярные выражения, прошу под кат.</p>
<!-- TEASER_END -->

<h2>Предыстория</h2>
<p>Одна из самописных систем отдела Business Intelligence нашей компании имеет интерфейс в виде несложного языка запросов. В первой версии системы язык этот интерпретировался на лету, без компиляции, непосредственно из входной строки с запросом. Вторая версия парсера будет работать уже с промежуточным байт-кодом, что позволит отделить язык запросов от их выполнения и сильно упростит код.</p>
<p>В процессе работы над второй версией системы у меня случился отпуск, в течение которого я на часик-другой каждый день отвлекался от дел семейных на изучение материалов, посвящённых архитектуре и производительности интерпретаторов байт-кода. Полученными в результате заметками и примерами интерпретаторов я решил поделиться с читателями Хабра в виде серии статей.</p>
<p>В первой из них представлено пять небольших (до сотни строк простенького кода на C) виртуальных машин(ок), каждая из которых раскрывает определённый аспект разработки таких интерпретаторов.</p>
<h2>Откуда есть пошли байт-коды в языках программирования</h2>
<p>Виртуальных машин, самых разнообразных виртуальных наборов инструкций за последние несколько десятков лет было придумано великое множество. Википедия утверждает, что первые языки программирования стали компилироваться в различные упрощённые промежуточные представления еще в 60-е годы прошлого века. Какие-то из этих первых байт-кодов преобразовывались в машинные коды и выполнялись реальными процессорами, другие - интерпретировались на лету процессорами виртуальными.</p>
<p>Популярность виртуальных наборов инструкций в качестве промежуточного представления кода объясняется тремя причинами:</p>
<ol>
<li>
<p>Программы в виде байт-кодов легко переносятся на новые платформы.</p>
</li>
<li>
<p>Интерпретаторы байт-кодов работают быстрее интерпретаторов синтаксического дерева кода.</p>
</li>
<li>
<p>Разработать простейшую виртуальную машину можно буквально за пару часов.</p>
</li>
</ol>
<p>Давайте сделаем несколько простейших виртуальных машин на C и на этих примерах выделим основные технические аспекты реализации виртуальных машин.</p>
<p>Полные коды примеров выложены на <a href="https://github.com/vkazanov/bytecode-interpreters-post">GitHub</a>. Примеры можно собрать любым относительно свежим GCC:</p>
<pre class="code literal-block"><span></span>gcc interpreter-basic-switch.c -o interpreter
./interpreter
</pre>


<p>Все примеры имеют одинаковую структуру: сначала идёт код самой виртуальной машины, после - главная функция с assert-ами, проверяющими работу кода. Я старался внятно комментировать опкоды и ключевые места интерпретаторов. Надеюсь, статья будет понятна даже людям, ежедневно не пишущим на C.</p>
<h2>Самый простой в мире интерпретатор байт-кода</h2>
<p>Как я уже говорил, простейший интерпретатор сделать очень легко. Комментарии - сразу за листингом, а начнём непосредственно с кода:</p>
<pre class="code literal-block"><span></span><span class="k">struct</span> <span class="p">{</span>
    <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">ip</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">accumulator</span><span class="p">;</span>
<span class="p">}</span> <span class="n">vm</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
    <span class="cm">/* increment the register */</span>
    <span class="n">OP_INC</span><span class="p">,</span>
    <span class="cm">/* decrement the register */</span>
    <span class="n">OP_DEC</span><span class="p">,</span>
    <span class="cm">/* stop execution */</span>
    <span class="n">OP_DONE</span>
<span class="p">}</span> <span class="n">opcode</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="n">interpret_result</span> <span class="p">{</span>
    <span class="n">SUCCESS</span><span class="p">,</span>
    <span class="n">ERROR_UNKNOWN_OPCODE</span><span class="p">,</span>
<span class="p">}</span> <span class="n">interpret_result</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">vm_reset</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">puts</span><span class="p">(</span><span class="s">"Reset vm state"</span><span class="p">);</span>
    <span class="n">vm</span> <span class="o">=</span> <span class="p">(</span><span class="n">typeof</span><span class="p">(</span><span class="n">vm</span><span class="p">))</span> <span class="p">{</span> <span class="nb">NULL</span> <span class="p">};</span>
<span class="p">}</span>

<span class="n">interpret_result</span> <span class="nf">vm_interpret</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">bytecode</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">vm_reset</span><span class="p">();</span>

    <span class="n">puts</span><span class="p">(</span><span class="s">"Start interpreting"</span><span class="p">);</span>
    <span class="n">vm</span><span class="p">.</span><span class="n">ip</span> <span class="o">=</span> <span class="n">bytecode</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
        <span class="kt">uint8_t</span> <span class="n">instruction</span> <span class="o">=</span> <span class="o">*</span><span class="n">vm</span><span class="p">.</span><span class="n">ip</span><span class="o">++</span><span class="p">;</span>
        <span class="k">switch</span> <span class="p">(</span><span class="n">instruction</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="nl">OP_INC</span><span class="p">:</span> <span class="p">{</span>
            <span class="n">vm</span><span class="p">.</span><span class="n">accumulator</span><span class="o">++</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">case</span> <span class="nl">OP_DEC</span><span class="p">:</span> <span class="p">{</span>
            <span class="n">vm</span><span class="p">.</span><span class="n">accumulator</span><span class="o">--</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">case</span> <span class="nl">OP_DONE</span><span class="p">:</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">SUCCESS</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">default</span><span class="o">:</span>
            <span class="k">return</span> <span class="n">ERROR_UNKNOWN_OPCODE</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</pre>


<p>Здесь меньше ста строк, но все характерные атрибуты виртуальной машины представлены. У машины единственный регистр (<code>vm.accumulator</code>), три операции (инкремент регистра, декремент регистра и завершение исполнения программы) и указатель на текущую инструкцию (<code>vm.ip</code>).</p>
<p>Каждая операция (англ. <em>operation code</em>, или <em>opcode</em>) кодируется одним байтом, а диспетчеризация осуществляется при помощи обычного <code>switch</code> в функции <code>vm_interpret</code>. Ветки в <code>switch</code> содержат логику операций, то есть меняют состояние регистра либо завершают исполнение программы.</p>
<p>Операции передаются в функцию <code>vm_interpret</code> в виде массива байтов - байт-кода (англ. <em>bytecode</em>) - и последовательно выполняются до тех пор, пока в байт-коде не встретится операция завершения работы виртуальной машины (<code>OP_DONE</code>).</p>
<p>Ключевой аспект виртуальной машины - семантика, то есть набор операций, которые над ней возможны. В данном случае операций только две, и они меняют значение единственного регистра.</p>
<p>Некоторые исследователи (<a href="https://www.sba-research.org/wp-content/uploads/publications/bytecode09.pdf">Virtual-machine Abstraction and Optimization Techniques</a>, 2009) предлагают разделять виртуальные машины на <em>высокоуровневые</em> и <em>низкоуровневые</em> по близости семантики виртуальной машины к семантике физической машины, на которой будет выполняться байт-код.</p>
<p>В предельном случае байт-код низкоуровневых виртуальных машин может полностью повторять машинный код физической машины с имитацией оперативной памяти, полным набором регистров, инструкциями работы со стеком и так далее. Виртуальная машина <a href="http://bochs.sourceforge.net">Bochs</a>, например, повторяет набор инструкций архитектуры x86.</p>
<p>И наоборот: операции высокоуровневых виртуальных машин близко отражают семантику компилируемого в байт-код специализированного языка программирования. Так работают, например, SQLite, Gawk и многочисленные версии Prolog.</p>
<p>Промежуточное положение занимают интерпретаторы языков программирования общего назначения, имеющие элементы как высокого, так и низкого уровней. В популярнейшей Java Virtual Machine есть как низкоуровневые инструкции для работы со стеком, так и встроенная поддержка объектно-ориентированного программирования с автоматическим выделением памяти.</p>
<p>Приведённый же код относится скорее к самым примитивным из низкоуровневых виртуальных машин: каждая виртуальная инструкция - обёртка над одной-двумя физическими инструкциями, виртуальный регистр же полностью соответствует одному регистру "железного" процессора.</p>
<h2>Аргументы инструкций в байт-коде</h2>
<p>Можно сказать, что единственный регистр в нашем примере виртуальной машины - одновременно и аргумент, и возвращаемое значение всех выполняемых инструкций. Однако нам может пригодиться возможность передавать аргументы в инструкции. Один из способов - прямо помещать их в байт-код.</p>
<p>Расширим пример, внеся инструкции (OP_ADDI, OP_SUBI), принимающие аргумент в виде байта, следующего непосредственно за опкодом:</p>
<pre class="code literal-block"><span></span><span class="k">struct</span> <span class="p">{</span>
    <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">ip</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">accumulator</span><span class="p">;</span>
<span class="p">}</span> <span class="n">vm</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
    <span class="cm">/* increment the register */</span>
    <span class="n">OP_INC</span><span class="p">,</span>
    <span class="cm">/* decrement the register */</span>
    <span class="n">OP_DEC</span><span class="p">,</span>
    <span class="cm">/* add the immediate argument to the register */</span>
    <span class="n">OP_ADDI</span><span class="p">,</span>
    <span class="cm">/* subtract the immediate argument from the register */</span>
    <span class="n">OP_SUBI</span><span class="p">,</span>
    <span class="cm">/* stop execution */</span>
    <span class="n">OP_DONE</span>
<span class="p">}</span> <span class="n">opcode</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="n">interpret_result</span> <span class="p">{</span>
    <span class="n">SUCCESS</span><span class="p">,</span>
    <span class="n">ERROR_UNKNOWN_OPCODE</span><span class="p">,</span>
<span class="p">}</span> <span class="n">interpret_result</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">vm_reset</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">puts</span><span class="p">(</span><span class="s">"Reset vm state"</span><span class="p">);</span>
    <span class="n">vm</span> <span class="o">=</span> <span class="p">(</span><span class="n">typeof</span><span class="p">(</span><span class="n">vm</span><span class="p">))</span> <span class="p">{</span> <span class="nb">NULL</span> <span class="p">};</span>
<span class="p">}</span>

<span class="n">interpret_result</span> <span class="nf">vm_interpret</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">bytecode</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">vm_reset</span><span class="p">();</span>

    <span class="n">puts</span><span class="p">(</span><span class="s">"Start interpreting"</span><span class="p">);</span>
    <span class="n">vm</span><span class="p">.</span><span class="n">ip</span> <span class="o">=</span> <span class="n">bytecode</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
        <span class="kt">uint8_t</span> <span class="n">instruction</span> <span class="o">=</span> <span class="o">*</span><span class="n">vm</span><span class="p">.</span><span class="n">ip</span><span class="o">++</span><span class="p">;</span>
        <span class="k">switch</span> <span class="p">(</span><span class="n">instruction</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="nl">OP_INC</span><span class="p">:</span> <span class="p">{</span>
            <span class="n">vm</span><span class="p">.</span><span class="n">accumulator</span><span class="o">++</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">case</span> <span class="nl">OP_DEC</span><span class="p">:</span> <span class="p">{</span>
            <span class="n">vm</span><span class="p">.</span><span class="n">accumulator</span><span class="o">--</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">case</span> <span class="nl">OP_ADDI</span><span class="p">:</span> <span class="p">{</span>
            <span class="cm">/* get the argument */</span>
            <span class="kt">uint8_t</span> <span class="n">arg</span> <span class="o">=</span> <span class="o">*</span><span class="n">vm</span><span class="p">.</span><span class="n">ip</span><span class="o">++</span><span class="p">;</span>
            <span class="n">vm</span><span class="p">.</span><span class="n">accumulator</span> <span class="o">+=</span> <span class="n">arg</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">case</span> <span class="nl">OP_SUBI</span><span class="p">:</span> <span class="p">{</span>
            <span class="cm">/* get the argument */</span>
            <span class="kt">uint8_t</span> <span class="n">arg</span> <span class="o">=</span> <span class="o">*</span><span class="n">vm</span><span class="p">.</span><span class="n">ip</span><span class="o">++</span><span class="p">;</span>
            <span class="n">vm</span><span class="p">.</span><span class="n">accumulator</span> <span class="o">-=</span> <span class="n">arg</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">case</span> <span class="nl">OP_DONE</span><span class="p">:</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">SUCCESS</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">default</span><span class="o">:</span>
            <span class="k">return</span> <span class="n">ERROR_UNKNOWN_OPCODE</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</pre>


<p>Новые инструкции (см. функцию <code>vm_interpret</code>) читают из байт-кода свой аргумент и прибавляют его к регистру / вычитают его из регистра.</p>
<p>Такой аргумент называется непосредственным аргументом (англ. <em>immediate argument</em>), поскольку он располагается прямо в массиве опкодов. Главное ограничение в нашей реализации заключается в том, что аргумент представляет собой один-единственный байт и может принимать только 256 значений.</p>
<p>В нашей виртуальной машине диапазон возможных значений аргументов инструкций не играет большой роли. Но если виртуальная машина будет использоваться в качестве интерпретатора настоящего языка, то имеет смысл усложнить байт-код, добавив в него отдельную от массива опкодов таблицу констант и инструкции с непосредственным аргументом, соответствующим адресу настоящего аргумента в таблице констант.</p>
<h2>Стековая машина</h2>
<p>Инструкции в нашей несложной виртуальной машине всегда работают с одним регистром и никак не могут передавать друг другу данные. Кроме того, аргумент у инструкции может быть только непосредственный, а, скажем, операции сложения или умножения принимают два аргумента.</p>
<p>Проще говоря, у нас нет никакой возможности вычислять сложные выражения. Для решения этой задачи необходима стековая машина, то есть виртуальная машина со встроенным стеком:</p>
<pre class="code literal-block"><span></span><span class="cp">#define STACK_MAX 256</span>

<span class="k">struct</span> <span class="p">{</span>
    <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">ip</span><span class="p">;</span>

    <span class="cm">/* Fixed-size stack */</span>
    <span class="kt">uint64_t</span> <span class="n">stack</span><span class="p">[</span><span class="n">STACK_MAX</span><span class="p">];</span>
    <span class="kt">uint64_t</span> <span class="o">*</span><span class="n">stack_top</span><span class="p">;</span>

    <span class="cm">/* A single register containing the result */</span>
    <span class="kt">uint64_t</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span> <span class="n">vm</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
    <span class="cm">/* push the immediate argument onto the stack */</span>
    <span class="n">OP_PUSHI</span><span class="p">,</span>
    <span class="cm">/* pop 2 values from the stack, add and push the result onto the stack */</span>
    <span class="n">OP_ADD</span><span class="p">,</span>
    <span class="cm">/* pop 2 values from the stack, subtract and push the result onto the stack */</span>
    <span class="n">OP_SUB</span><span class="p">,</span>
    <span class="cm">/* pop 2 values from the stack, divide and push the result onto the stack */</span>
    <span class="n">OP_DIV</span><span class="p">,</span>
    <span class="cm">/* pop 2 values from the stack, multiply and push the result onto the stack */</span>
    <span class="n">OP_MUL</span><span class="p">,</span>
    <span class="cm">/* pop the top of the stack and set it as execution result */</span>
    <span class="n">OP_POP_RES</span><span class="p">,</span>
    <span class="cm">/* stop execution */</span>
    <span class="n">OP_DONE</span><span class="p">,</span>
<span class="p">}</span> <span class="n">opcode</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="n">interpret_result</span> <span class="p">{</span>
    <span class="n">SUCCESS</span><span class="p">,</span>
    <span class="n">ERROR_DIVISION_BY_ZERO</span><span class="p">,</span>
    <span class="n">ERROR_UNKNOWN_OPCODE</span><span class="p">,</span>
<span class="p">}</span> <span class="n">interpret_result</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">vm_reset</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">puts</span><span class="p">(</span><span class="s">"Reset vm state"</span><span class="p">);</span>
    <span class="n">vm</span> <span class="o">=</span> <span class="p">(</span><span class="n">typeof</span><span class="p">(</span><span class="n">vm</span><span class="p">))</span> <span class="p">{</span> <span class="nb">NULL</span> <span class="p">};</span>
    <span class="n">vm</span><span class="p">.</span><span class="n">stack_top</span> <span class="o">=</span> <span class="n">vm</span><span class="p">.</span><span class="n">stack</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">vm_stack_push</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
    <span class="o">*</span><span class="n">vm</span><span class="p">.</span><span class="n">stack_top</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
    <span class="n">vm</span><span class="p">.</span><span class="n">stack_top</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">uint64_t</span> <span class="nf">vm_stack_pop</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">vm</span><span class="p">.</span><span class="n">stack_top</span><span class="o">--</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">*</span><span class="n">vm</span><span class="p">.</span><span class="n">stack_top</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">interpret_result</span> <span class="nf">vm_interpret</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">bytecode</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">vm_reset</span><span class="p">();</span>

    <span class="n">puts</span><span class="p">(</span><span class="s">"Start interpreting"</span><span class="p">);</span>
    <span class="n">vm</span><span class="p">.</span><span class="n">ip</span> <span class="o">=</span> <span class="n">bytecode</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
        <span class="kt">uint8_t</span> <span class="n">instruction</span> <span class="o">=</span> <span class="o">*</span><span class="n">vm</span><span class="p">.</span><span class="n">ip</span><span class="o">++</span><span class="p">;</span>
        <span class="k">switch</span> <span class="p">(</span><span class="n">instruction</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="nl">OP_PUSHI</span><span class="p">:</span> <span class="p">{</span>
            <span class="cm">/* get the argument, push it onto stack */</span>
            <span class="kt">uint8_t</span> <span class="n">arg</span> <span class="o">=</span> <span class="o">*</span><span class="n">vm</span><span class="p">.</span><span class="n">ip</span><span class="o">++</span><span class="p">;</span>
            <span class="n">vm_stack_push</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">case</span> <span class="nl">OP_ADD</span><span class="p">:</span> <span class="p">{</span>
            <span class="cm">/* Pop 2 values, add 'em, push the result back to the stack */</span>
            <span class="kt">uint64_t</span> <span class="n">arg_right</span> <span class="o">=</span> <span class="n">vm_stack_pop</span><span class="p">();</span>
            <span class="kt">uint64_t</span> <span class="n">arg_left</span> <span class="o">=</span> <span class="n">vm_stack_pop</span><span class="p">();</span>
            <span class="kt">uint64_t</span> <span class="n">res</span> <span class="o">=</span> <span class="n">arg_left</span> <span class="o">+</span> <span class="n">arg_right</span><span class="p">;</span>
            <span class="n">vm_stack_push</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">case</span> <span class="nl">OP_SUB</span><span class="p">:</span> <span class="p">{</span>
            <span class="cm">/* Pop 2 values, subtract 'em, push the result back to the stack */</span>
            <span class="kt">uint64_t</span> <span class="n">arg_right</span> <span class="o">=</span> <span class="n">vm_stack_pop</span><span class="p">();</span>
            <span class="kt">uint64_t</span> <span class="n">arg_left</span> <span class="o">=</span> <span class="n">vm_stack_pop</span><span class="p">();</span>
            <span class="kt">uint64_t</span> <span class="n">res</span> <span class="o">=</span> <span class="n">arg_left</span> <span class="o">-</span> <span class="n">arg_right</span><span class="p">;</span>
            <span class="n">vm_stack_push</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">case</span> <span class="nl">OP_DIV</span><span class="p">:</span> <span class="p">{</span>
            <span class="cm">/* Pop 2 values, divide 'em, push the result back to the stack */</span>
            <span class="kt">uint64_t</span> <span class="n">arg_right</span> <span class="o">=</span> <span class="n">vm_stack_pop</span><span class="p">();</span>
            <span class="cm">/* Don't forget to handle the div by zero error */</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">arg_right</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">ERROR_DIVISION_BY_ZERO</span><span class="p">;</span>
            <span class="kt">uint64_t</span> <span class="n">arg_left</span> <span class="o">=</span> <span class="n">vm_stack_pop</span><span class="p">();</span>
            <span class="kt">uint64_t</span> <span class="n">res</span> <span class="o">=</span> <span class="n">arg_left</span> <span class="o">/</span> <span class="n">arg_right</span><span class="p">;</span>
            <span class="n">vm_stack_push</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">case</span> <span class="nl">OP_MUL</span><span class="p">:</span> <span class="p">{</span>
            <span class="cm">/* Pop 2 values, multiply 'em, push the result back to the stack */</span>
            <span class="kt">uint64_t</span> <span class="n">arg_right</span> <span class="o">=</span> <span class="n">vm_stack_pop</span><span class="p">();</span>
            <span class="kt">uint64_t</span> <span class="n">arg_left</span> <span class="o">=</span> <span class="n">vm_stack_pop</span><span class="p">();</span>
            <span class="kt">uint64_t</span> <span class="n">res</span> <span class="o">=</span> <span class="n">arg_left</span> <span class="o">*</span> <span class="n">arg_right</span><span class="p">;</span>
            <span class="n">vm_stack_push</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">case</span> <span class="nl">OP_POP_RES</span><span class="p">:</span> <span class="p">{</span>
            <span class="cm">/* Pop the top of the stack, set it as a result value */</span>
            <span class="kt">uint64_t</span> <span class="n">res</span> <span class="o">=</span> <span class="n">vm_stack_pop</span><span class="p">();</span>
            <span class="n">vm</span><span class="p">.</span><span class="n">result</span> <span class="o">=</span> <span class="n">res</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">case</span> <span class="nl">OP_DONE</span><span class="p">:</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">SUCCESS</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">default</span><span class="o">:</span>
            <span class="k">return</span> <span class="n">ERROR_UNKNOWN_OPCODE</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</pre>


<p>В этом примере операций уже больше, и почти все они работают только со стеком. OP_PUSHI помещает на стек свой непосредственный аргумент. Инструкции OP_ADD, OP_SUB, OP_DIV, OP_MUL извлекают по паре значений из стека, вычисляют результат и помещают его обратно на стек. OP_POP_RES снимает значение со стека и помещает его в регистр result, предназначенный для результатов работы виртуальной машины.</p>
<p>Для операции деления (OP_DIV) отлавливается ошибка деления на ноль, что останавливает работу виртуальной машины.</p>
<p>Возможности такой машины намного шире предыдущей с единственным регистром и позволяют, например, вычислять сложные арифметические выражения. Другим (и немаловажным!) преимуществом является простота компиляции языков программирования в байт-код стековой машины.</p>
<h2>Регистровая машина</h2>
<p>Благодаря своей простоте стековые виртуальные машины получили самое широкое распространение среди разработчиков языков программирования; те же JVM и Python VM используют именно их.</p>
<p>Однако у таких машин есть и недостатки: в них приходится добавлять специальные инструкции для работы со стеком, при вычислении выражений все аргументы многократно проходят через единственную структуру данных, в стековом коде неизбежно появляется множество лишних инструкций.</p>
<p>Между тем выполнение каждой лишней инструкции влечёт за собой затраты на диспетчеризацию, то есть декодирование опкода и переход к телу инструкций.</p>
<p>Альтернатива стековым машинам - регистровые виртуальные машины. У них более сложный байт-код: в каждой инструкции явно закодированы номер регистров-аргументов и номер регистра-результата. Соответственно, вместо стека в качестве хранилища промежуточных значений используется расширенный набор регистров.</p>
<pre class="code literal-block"><span></span><span class="cp">#define REGISTER_NUM 16</span>

<span class="k">struct</span> <span class="p">{</span>
    <span class="kt">uint16_t</span> <span class="o">*</span><span class="n">ip</span><span class="p">;</span>

    <span class="cm">/* Register array */</span>
    <span class="kt">uint64_t</span> <span class="n">reg</span><span class="p">[</span><span class="n">REGISTER_NUM</span><span class="p">];</span>

    <span class="cm">/* A single register containing the result */</span>
    <span class="kt">uint64_t</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span> <span class="n">vm</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
    <span class="cm">/* Load an immediate value into r0  */</span>
    <span class="n">OP_LOADI</span><span class="p">,</span>
    <span class="cm">/* Add values in r0,r1 registers and put them into r2 */</span>
    <span class="n">OP_ADD</span><span class="p">,</span>
    <span class="cm">/* Subtract values in r0,r1 registers and put them into r2 */</span>
    <span class="n">OP_SUB</span><span class="p">,</span>
    <span class="cm">/* Divide values in r0,r1 registers and put them into r2 */</span>
    <span class="n">OP_DIV</span><span class="p">,</span>
    <span class="cm">/* Multiply values in r0,r1 registers and put them into r2 */</span>
    <span class="n">OP_MUL</span><span class="p">,</span>
    <span class="cm">/* Move a value from r0 register into the result register */</span>
    <span class="n">OP_MOV_RES</span><span class="p">,</span>
    <span class="cm">/* stop execution */</span>
    <span class="n">OP_DONE</span><span class="p">,</span>
<span class="p">}</span> <span class="n">opcode</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="n">interpret_result</span> <span class="p">{</span>
    <span class="n">SUCCESS</span><span class="p">,</span>
    <span class="n">ERROR_DIVISION_BY_ZERO</span><span class="p">,</span>
    <span class="n">ERROR_UNKNOWN_OPCODE</span><span class="p">,</span>
<span class="p">}</span> <span class="n">interpret_result</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">vm_reset</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">puts</span><span class="p">(</span><span class="s">"Reset vm state"</span><span class="p">);</span>
    <span class="n">vm</span> <span class="o">=</span> <span class="p">(</span><span class="n">typeof</span><span class="p">(</span><span class="n">vm</span><span class="p">))</span> <span class="p">{</span> <span class="nb">NULL</span> <span class="p">};</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">decode</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">instruction</span><span class="p">,</span>
            <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">op</span><span class="p">,</span>
            <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">reg0</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">reg1</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">reg2</span><span class="p">,</span>
            <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">imm</span><span class="p">)</span>
<span class="p">{</span>
    <span class="o">*</span><span class="n">op</span> <span class="o">=</span> <span class="p">(</span><span class="n">instruction</span> <span class="o">&amp;</span> <span class="mh">0xF000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">;</span>
    <span class="o">*</span><span class="n">reg0</span> <span class="o">=</span> <span class="p">(</span><span class="n">instruction</span> <span class="o">&amp;</span> <span class="mh">0x0F00</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
    <span class="o">*</span><span class="n">reg1</span> <span class="o">=</span> <span class="p">(</span><span class="n">instruction</span> <span class="o">&amp;</span> <span class="mh">0x00F0</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">;</span>
    <span class="o">*</span><span class="n">reg2</span> <span class="o">=</span> <span class="p">(</span><span class="n">instruction</span> <span class="o">&amp;</span> <span class="mh">0x000F</span><span class="p">);</span>
    <span class="o">*</span><span class="n">imm</span> <span class="o">=</span> <span class="p">(</span><span class="n">instruction</span> <span class="o">&amp;</span> <span class="mh">0x00FF</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">interpret_result</span> <span class="nf">vm_interpret</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="o">*</span><span class="n">bytecode</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">vm_reset</span><span class="p">();</span>
    <span class="n">puts</span><span class="p">(</span><span class="s">"Start interpreting"</span><span class="p">);</span>
    <span class="n">vm</span><span class="p">.</span><span class="n">ip</span> <span class="o">=</span> <span class="n">bytecode</span><span class="p">;</span>

    <span class="kt">uint8_t</span> <span class="n">op</span><span class="p">,</span> <span class="n">r0</span><span class="p">,</span> <span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">,</span> <span class="n">immediate</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
        <span class="cm">/* fetch the instruction */</span>
        <span class="kt">uint16_t</span> <span class="n">instruction</span> <span class="o">=</span> <span class="o">*</span><span class="n">vm</span><span class="p">.</span><span class="n">ip</span><span class="o">++</span><span class="p">;</span>
        <span class="cm">/* decode it */</span>
        <span class="n">decode</span><span class="p">(</span><span class="n">instruction</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">op</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">immediate</span><span class="p">);</span>
        <span class="cm">/* dispatch */</span>
        <span class="k">switch</span> <span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="nl">OP_LOADI</span><span class="p">:</span> <span class="p">{</span>
            <span class="n">vm</span><span class="p">.</span><span class="n">reg</span><span class="p">[</span><span class="n">r0</span><span class="p">]</span> <span class="o">=</span> <span class="n">immediate</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">case</span> <span class="nl">OP_ADD</span><span class="p">:</span> <span class="p">{</span>
            <span class="n">vm</span><span class="p">.</span><span class="n">reg</span><span class="p">[</span><span class="n">r2</span><span class="p">]</span> <span class="o">=</span> <span class="n">vm</span><span class="p">.</span><span class="n">reg</span><span class="p">[</span><span class="n">r0</span><span class="p">]</span> <span class="o">+</span> <span class="n">vm</span><span class="p">.</span><span class="n">reg</span><span class="p">[</span><span class="n">r1</span><span class="p">];</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">case</span> <span class="nl">OP_SUB</span><span class="p">:</span> <span class="p">{</span>
            <span class="n">vm</span><span class="p">.</span><span class="n">reg</span><span class="p">[</span><span class="n">r2</span><span class="p">]</span> <span class="o">=</span> <span class="n">vm</span><span class="p">.</span><span class="n">reg</span><span class="p">[</span><span class="n">r0</span><span class="p">]</span> <span class="o">-</span> <span class="n">vm</span><span class="p">.</span><span class="n">reg</span><span class="p">[</span><span class="n">r1</span><span class="p">];</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">case</span> <span class="nl">OP_DIV</span><span class="p">:</span> <span class="p">{</span>
            <span class="cm">/* Don't forget to handle the div by zero error */</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">vm</span><span class="p">.</span><span class="n">reg</span><span class="p">[</span><span class="n">r1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">ERROR_DIVISION_BY_ZERO</span><span class="p">;</span>
            <span class="n">vm</span><span class="p">.</span><span class="n">reg</span><span class="p">[</span><span class="n">r2</span><span class="p">]</span> <span class="o">=</span> <span class="n">vm</span><span class="p">.</span><span class="n">reg</span><span class="p">[</span><span class="n">r0</span><span class="p">]</span> <span class="o">/</span> <span class="n">vm</span><span class="p">.</span><span class="n">reg</span><span class="p">[</span><span class="n">r1</span><span class="p">];</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">case</span> <span class="nl">OP_MUL</span><span class="p">:</span> <span class="p">{</span>
            <span class="n">vm</span><span class="p">.</span><span class="n">reg</span><span class="p">[</span><span class="n">r2</span><span class="p">]</span> <span class="o">=</span> <span class="n">vm</span><span class="p">.</span><span class="n">reg</span><span class="p">[</span><span class="n">r0</span><span class="p">]</span> <span class="o">*</span> <span class="n">vm</span><span class="p">.</span><span class="n">reg</span><span class="p">[</span><span class="n">r1</span><span class="p">];</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">case</span> <span class="nl">OP_MOV_RES</span><span class="p">:</span> <span class="p">{</span>
            <span class="n">vm</span><span class="p">.</span><span class="n">result</span> <span class="o">=</span> <span class="n">vm</span><span class="p">.</span><span class="n">reg</span><span class="p">[</span><span class="n">r0</span><span class="p">];</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">case</span> <span class="nl">OP_DONE</span><span class="p">:</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">SUCCESS</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">default</span><span class="o">:</span>
            <span class="k">return</span> <span class="n">ERROR_UNKNOWN_OPCODE</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</pre>


<p>В примере показана регистровая машина на 16 регистров. Инструкции занимают по 16 бит каждая и кодируются тремя способами:</p>
<ol>
<li>
<p>4 бита на код операции + 4 бита на имя регистра + 8 бит на аргумент.</p>
</li>
<li>
<p>4 бита на код операции + трижды по 4 бита на имена регистров.</p>
</li>
<li>
<p>4 бита на код операции + 4 бита на единственное имя регистра + 8 неиспользованных бит.</p>
</li>
</ol>
<p>У нашей небольшой виртуальной машины совсем мало операций, поэтому четырёх бит (или 16 возможных операций) на опкод вполне достаточно. Операция определяет, что именно представляют оставшиеся биты инструкции.</p>
<p>Первый вид кодирования (4 + 4 + 8) нужен для загрузки данных в регистры операцией OP_LOADI. Второй вид (4 + 4 + 4 + 4) используется для арифметических операций, которые должны знать, где брать пару аргументов и куда складывать результат вычисления. И, наконец, последний вид (4 + 4 + 8 ненужных бит) используется для инструкций с единственным регистром в качестве аргумента, в нашем случае это OP_MOV_RES.</p>
<p>Для кодирования и декодирования инструкций теперь нужна специальная логика (функция <code>decode</code>). С другой стороны, логика инструкций благодаря явному указанию на расположение аргументов становится проще - исчезают операции со стеком.</p>
<p>Ключевые особенности: в байт-коде регистровых машин меньше инструкций, отдельные инструкции шире, компиляция в такой байт-код сложнее - компилятору приходится решать, как использовать доступные регистры.</p>
<p>Надо заметить, что на практике в регистровых виртуальных машинах обычно есть и стек, куда помещаются, например, аргументы функций; регистры же используются для вычисления отдельных выражений. Даже если явного стека нет, то для построения стека используется массив, играющий ту же роль, что оперативная память в физических машинах.</p>
<h2>Стековые и регистровые машины, сравнение</h2>
<p>Есть интересное исследование (<a href="https://www.usenix.org/events/vee05/full_papers/p153-yunhe.pdf">Virtual machine showdown: Stack versus registers</a>, 2008), оказавшее большое влияние на все последующие разработки в области виртуальных машин для языков программирования. Его авторы предложили способ прямой трансляции из стекового кода стандартной JVM в регистровый код и сравнили производительность.</p>
<p>Способ нетривиальный: код сначала транслируется, а потом достаточно сложным образом оптимизируется. Но последующее сравнение производительности одной и той же программы показало, что дополнительные циклы процессора, затраченные на декодирование инструкций, полностью компенсируются уменьшением общего числа инструкций. В общем, если коротко, регистровая машина оказалась эффективнее стековой.</p>
<p>Как уже упоминалось выше, у этой эффективности есть вполне осязаемая цена: компилятор должен сам аллоцировать регистры и дополнительно желательно наличие развитого оптимизатора.</p>
<p>Спор о том, какая же архитектура лучше, всё ещё не закончен. Если говорить о компиляторах Java, то байт-код Dalvik VM, до недавних пор работавший в каждом Android-устройстве, был регистровым; но титульная JVM сохранила стековый набор инструкций. Виртуальная машина Lua использует регистровую машину, но Python VM - по-прежнему стековая. И так далее.</p>
<h2>Байт-код в интерпретаторах регулярных выражений</h2>
<p>Наконец, чтобы отвлечься от низкоуровневых виртуальных машин, давайте рассмотрим специализированный интерпретатор, проверяющий строки на соответствие регулярному выражению:</p>
<pre class="code literal-block"><span></span><span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
    <span class="cm">/* match a single char to an immediate argument from the string and advance ip and cp, or</span>
<span class="cm">     * abort*/</span>
    <span class="n">OP_CHAR</span><span class="p">,</span>
    <span class="cm">/* jump to and match either left expression or the right one, abort if nothing matches*/</span>
    <span class="n">OP_OR</span><span class="p">,</span>
    <span class="cm">/* do an absolute jump to an offset in the immediate argument */</span>
    <span class="n">OP_JUMP</span><span class="p">,</span>
    <span class="cm">/* stop execution and report a successful match */</span>
    <span class="n">OP_MATCH</span><span class="p">,</span>
<span class="p">}</span> <span class="n">opcode</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="n">match_result</span> <span class="p">{</span>
    <span class="n">MATCH_OK</span><span class="p">,</span>
    <span class="n">MATCH_FAIL</span><span class="p">,</span>
    <span class="n">MATCH_ERROR</span><span class="p">,</span>
<span class="p">}</span> <span class="n">match_result</span><span class="p">;</span>

<span class="n">match_result</span> <span class="nf">vm_match_recur</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">bytecode</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">ip</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sp</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
        <span class="kt">uint8_t</span> <span class="n">instruction</span> <span class="o">=</span> <span class="o">*</span><span class="n">ip</span><span class="o">++</span><span class="p">;</span>
        <span class="k">switch</span> <span class="p">(</span><span class="n">instruction</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="nl">OP_CHAR</span><span class="p">:{</span>
            <span class="kt">char</span> <span class="n">cur_c</span> <span class="o">=</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>
            <span class="kt">char</span> <span class="n">arg_c</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="o">*</span><span class="n">ip</span> <span class="p">;</span>
            <span class="cm">/* no match? FAILed to match */</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">arg_c</span> <span class="o">!=</span> <span class="n">cur_c</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">MATCH_FAIL</span><span class="p">;</span>
            <span class="cm">/* advance both current instruction and character pointers */</span>
            <span class="n">ip</span><span class="o">++</span><span class="p">;</span>
            <span class="n">sp</span><span class="o">++</span><span class="p">;</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">case</span> <span class="nl">OP_JUMP</span><span class="p">:{</span>
            <span class="cm">/* read the offset and jump to the instruction */</span>
            <span class="kt">uint8_t</span> <span class="n">offset</span> <span class="o">=</span> <span class="o">*</span><span class="n">ip</span><span class="p">;</span>
            <span class="n">ip</span> <span class="o">=</span> <span class="n">bytecode</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">case</span> <span class="nl">OP_OR</span><span class="p">:{</span>
            <span class="cm">/* get both branch offsets */</span>
            <span class="kt">uint8_t</span> <span class="n">left_offset</span> <span class="o">=</span> <span class="o">*</span><span class="n">ip</span><span class="o">++</span><span class="p">;</span>
            <span class="kt">uint8_t</span> <span class="n">right_offset</span> <span class="o">=</span> <span class="o">*</span><span class="n">ip</span><span class="p">;</span>
            <span class="cm">/* check if following the first offset get a match */</span>
            <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">left_ip</span> <span class="o">=</span> <span class="n">bytecode</span> <span class="o">+</span> <span class="n">left_offset</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">vm_match_recur</span><span class="p">(</span><span class="n">bytecode</span><span class="p">,</span> <span class="n">left_ip</span><span class="p">,</span> <span class="n">sp</span><span class="p">)</span> <span class="o">==</span> <span class="n">MATCH_OK</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">MATCH_OK</span><span class="p">;</span>
            <span class="cm">/* no match? Check the second branch */</span>
            <span class="n">ip</span> <span class="o">=</span> <span class="n">bytecode</span> <span class="o">+</span> <span class="n">right_offset</span><span class="p">;</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">case</span> <span class="nl">OP_MATCH</span><span class="p">:{</span>
            <span class="cm">/* success */</span>
            <span class="k">return</span> <span class="n">MATCH_OK</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">MATCH_ERROR</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">match_result</span> <span class="nf">vm_match</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">bytecode</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Start matching a string: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">vm_match_recur</span><span class="p">(</span><span class="n">bytecode</span><span class="p">,</span> <span class="n">bytecode</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>
<span class="p">}</span>
</pre>


<p>Главная инструкция - OP_CHAR. Она берёт свой непосредственный аргумент и сравнивает его с текущим символом в строке (<code>char *sp</code>). В случае совпадения ожидаемого и текущего символов в строке происходит переход к следующей инструкции и следующему символу.</p>
<p>Машина также понимает операцию перехода (OP_JUMP), принимающую единственный непосредственный аргумент. Аргумент означает абсолютное смещение в байт-коде, откуда следует продолжать вычисление.</p>
<p>Последняя важная операция - OP_OR. Она принимает два смещения, пробуя применить сначала код по первому из них, потом, в случае ошибки, второму. Делает она это при помощи рекурсивного вызова, то есть инструкция делает обход в глубину дерева всех возможных вариантов регулярного выражения.</p>
<p>Удивительно, но четырёх опкодов и семидесяти строк кода достаточно, чтобы выразить регулярные выражения вида "abc", "a?bc", "(ab|bc)d", "a*bc". В этой виртуальной машине даже нет явного состояния, так как всё необходимое - указатели на начало потока инструкций, текущую инструкцию и текущий символ - передаётся аргументами рекурсивной функции.</p>
<p>Если вам интересны детали работы движков регулярных выражений, для начала можете ознакомиться с <a href="https://swtch.com/~rsc/regexp/">серией статей</a> Расса Кокса (англ. <em>Russ Cox</em>), автора движка для работы с регулярными выражениями от Google <a href="https://github.com/google/re2">RE2</a>.</p>
<h2>Итоги</h2>
<p>Давайте подведём итоги.</p>
<p>Для языков программирования общего назначения используются, как правило, две архитектуры: стековая и регистровая.</p>
<p>В стековой модели основной структурой данных и способом передачи аргументов между инструкциями является стек. В регистровой модели для вычисления выражений используется набор регистров, но для хранения аргументов функций всё равно используется явный или неявный стек.</p>
<p>Наличие явного стека и набора регистров приближает такие машины к низкоуровневым и даже физическим. Обилие низкоуровневых инструкций в таком байт-коде означает, что существенные затраты ресурсов физического процессора приходятся на декодирование и диспетчеризацию виртуальных инструкций.</p>
<p>С другой стороны, в популярных виртуальных машинах большую роль играют и высокоуровневые инструкции. В Java, например, это инструкции полиморфных вызовов функций, аллокация объектов и сборка мусора.</p>
<p>Чисто высокоуровневые виртуальные машины - к примеру, интерпретаторы байт-кодов языков с развитой и далёкой от железа семантикой - большую часть времени проводят не в диспетчере или декодере, а в телах инструкций и, соответственно, относительно эффективны.</p>
<p>Практические рекомендации:</p>
<ol>
<li>
<p>Если вам понадобилось исполнить какой-либо байт-код и сделать это в разумные сроки, то постарайтесь оперировать инструкциями, наиболее близкими к вашей задаче; чем выше семантический уровень, тем лучше. Это снизит затраты на диспетчеризацию и упростит генерацию кода.</p>
</li>
<li>
<p>Если потребовались большая гибкость и разнородная семантика, то следует хотя бы попробовать выделить общий знаменатель в байт-коде так, чтобы результирующие инструкции были на условно среднем уровне.</p>
</li>
<li>
<p>Если в перспективе может понадобиться вычислять какие-либо выражения, делайте стековую машину, это уменьшит головную боль при компиляции байт-кода.</p>
</li>
<li>
<p>Если выражений не предвидится, то делайте тривиальную регистровую машину, что позволит избежать затрат на стек и упростит сами инструкции.</p>
</li>
</ol>
<p>В следующих статьях я разберу практические реализации виртуальных машин в популярных языках программирования и расскажу, зачем отделу Business Intelligence Badoo понадобился байт-код.</p>
</div>
    </div>
    <aside class="postpromonav"><nav></nav></aside></article><!--End of body content--><footer id="footer">
            © 2019         «<a href="mailto:n.tesla@example.com">Языки и компиляторы</a>»
            
        </footer>
</div>
</div>


            <script src="../../assets/js/jquery.min.js"></script><script src="../../assets/js/popper.min.js"></script><script src="../../assets/js/bootstrap.min.js"></script><script src="../../assets/js/baguetteBox.min.js"></script><script src="../../assets/js/moment-with-locales.min.js"></script><script src="../../assets/js/fancydates.min.js"></script><!-- fancy dates --><script>
    moment.locale("ru");
    fancydates(2, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script>
</body>
</html>
